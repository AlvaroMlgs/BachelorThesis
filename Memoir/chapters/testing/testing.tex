
\let\textcircled=\pgftextcircled
\chapter{Testing and results} \label{chapter:testing}

\initial{I}n order to prove the effectiveness of the Obstacle Collision Avoidance System, it needs to be tested to prove that it meets the requirements and design specifications.
Hence, a set of individual tests have to be designed to assess the capabilities of each of the components involved in the system.

The present chapter will cover the experimental setups and results of those experiments performed on the critical components, subsystems and, finally, the system as a whole in a realistic environment.


\section{Testing methods}

Most of the testing was done in parallel to the implementation of the design into the real product, ensuring that the system was built over robust and properly working components, since possible modifications to the design are significantly more costly the later the development phase in which errors are detected (Figure \ref{fig:incose}).
Furthermore, tests can give valuable insight on the functioning of the components, which can prove useful in the decision making process within the implementation stages, effectively improving the overall performance of the system.

Thus, the actions described in this chapter can be seen as complementary and, in some sense also contributing, to the implementation phase of the OCAS.

\subsection{Component testing}

The validation of each individual component is assumed to be successfully done by the manufacturer.
Therefore, comprehensive testing will only be performed on the parts of the system that have been actively developed during the execution of this project, such as the interfaces and the operation algorithms of the ultrasonic rangefinders, since they are a critical component of the OCAS.

\subsubsection{Interfaces}

Assuming that the stock UAV interfaces (RC transmitter / receiver, telemetry link with GCS) are already tested and working, the connections to be verified are those involving the OCAS only, shown in Figure \ref{fig:ocas}.
In particular, the GCS connection over WiFi is of higher interest, since the power connection is straightforward to check by ensuring that the Raspberry Pi boots when plugged; and the MAVlink serial connection should not entail any difficulty once the appropriate communication port and baud rate are selected upon startup of MAVproxy (which is automatically done when using the GUI for that purpose).
Also, the testing of the GPIO connection will be covered in Section \ref{sec:sonartest}.

Concerning the network connection of the Raspberry Pi, it is controlled by the Raspbian OS.
Having set up the ad-hoc network from the Windows machine at the GCS as specified in Appendix \ref{app:network}, the Dynamic Host Configuration Protocol (DHCP) server should be properly configured to imitate the Local Area Network (LAN) settings to which the GCS machine is connected.
Thus, the DHCP service will provide the Raspberry Pi with a compatible IP, together with other important network parameters, automatically. 

Nevertheless, the problem with DHCP is that the address of the computers connected to the network will occasionally change, altering the settings for a successful SSH connection (those varying setting can be found by following the steps in Appendix \ref{app:ssh}).
Thus, for a more convenient debugging option, an static IP interface was selected on the Raspberry Pi's ethernet port.

Finally, in order to resemble the described setting on the Raspberry Pi, the configuration must be done by modifying the \texttt{interfaces} file which is present in all Debian-based Operating Systems at /etc/network/interfaces.
The specific file for the OCAS computer board is copied in Appendix \ref{app:interfaces} for completeness, together with an example of the \texttt{wpa\_suplicant.conf} file which holds the parameters for the wireless network connections.

In terms of the evaluation of the connection, considering the scope of the project, it is considered that the interface is successfully connected if the communication is responsive and stable, which can be certainly proven by construction\footnote{From Wolfram Mathworld: A constructive proof is a proof that directly provides a specific example, or which gives an algorithm for producing an example. Constructive proofs are also called demonstrative proofs}, following the steps in Appendices \ref{app:network} and \ref{app:ssh}.

\subsubsection{Ultrasonic rangefinders} \label{sec:sonartest}

The selected HC-SR04 sensors are mainly built to be connected to Arduino microcontrolers, which operate at 5 V.
Hence, in order to obtain some familiarity with their usage, as documented by the manufacturer (see Appendix \ref{app:sonar-doc}), the operation was initially made from an Arduino Mega board, which would trigger the ultrasonic signal and receive the processed echo to be transformed into the distance to the closest obstacle.

Ensuring that all the connections on the Arduino board were successful, the following logical step is to perform the same test from the Raspberry Pi, which inherits the inclusion of the voltage dividers (Figure \ref{fig:voltage}) and the Python GPIO libraries.
It was during this stage that the \texttt{Sonar} class was developed, requiring only a ``driver'' file that would make calls to the \texttt{Sonar}'s methods, which can be found in Appendix \ref{app:sonarDriver}.

Apart from triggering the ultrasonic rangefinders, the driver file would print the measured distance for any amount of attached sensors and display a graph with their values together with the calculated velocity, to help with their study in the Results section.


\subsection{Software testing: SITL}

Prior to the implementation of the OCAS in the real UAV, and knowing by individual tests that the hardware components were working properly, it was necessary to test the definition of the MAVlink messages that were to be sent to control the UAV in flight.
Furthermore, it was of utmost importance that the navigation coordinates were correctly defined, and also the transformations between different reference systems, since the MAVlink protocol only supports commands in the global (latitude, longitude, altitude) reference system, while for physical obstacle navigation it is more convenient to define the procedures either in Flat Earth (North, East, Down) or even body fixed (x, y, z) reference frames, from which the transformations needed to be computed.

To ensure safety during the software testing phase, the scripts were initially tested in a simulator.
In particular, the DroneKit development team provides a Software-In-The-Loop (SITL) simulator that works in a similar manner than a real Ardupilot UAV would.

Software-In-The-Loop means that, for the control algorithms, only software input is considered.
Hence, the physical characteristics of the UAV, together with its default sensors (IMU, barometer, GPS\ldots) all have what is considered to be a reasonably accurate software representation of their hardware counterparts (accuracy which, in the case of the SITL simulator, is not where the emphasis has been put as studied in \cite{vegaastorga2016}).
Nevertheless, the existent inaccuracies do not present any major problems for the script testing since the closed-loop PID control algorithms ensure that disturbances and errors are cancelled, finally reaching the requested state albeit by taking slightly different transient responses.

What is of higher importance in the software testing phase is the actual interpretation of the MAVlink commands by the Ardupilot control board, and the general physical response to them.
Fortunately, it is in the Ardupilot firmware simulation where the SITL software excels, since the simulator runs the exact same source code, only adapted to run on a regular computer rather than an Arduino board and to receive input from the software models rather than the real sensors.

However, the simulation of the default sensors via software means that the OCAS is not implemented (for being a custom build for this project).
Thus, the $t_{safe}<0$ condition can not be computed in the simulated environment.
For the purpose of testing, the sonars step in the \texttt{main.py} file of the custom script was adapted to include the monitorisation of Channel 7 on the RC transmitter, which would cause the same reaction as the ultrasonic rangefinders at the change of state of the corresponding switch, by modifying the lines 41 to 93 on Appendix \ref{app:main} by the fragment of code in Appendix \ref{app:ch7}, accompanied by the \texttt{Observe} class.

Finally, it is worth mentioning the role of the simulator within the rest of the subsystems of the OCAS, since SITL is only aimed at replacing the UAV block from Figure \ref{fig:ocas}.
The MAVlink stream of data out of the simulator is transmitted using the TCP protocol, which can be substituted in the MAVproxy startup options instead of the serial address that is used for the connection with the UAV.
Hence, the two leftmost blocks in Figure \ref{fig:mavproxy} would be substituted by the simulator, with the TCP interface with MAVproxy, being this change completely transparent to the Python script, which does not need any further modification.

In addition, in the Windows version of the GUI application, the option to launch the simulator and autocomplete the address and port fields on the MAVproxy parameters (see Figure \ref{fig:gui}) was included to facilitate the testing stages of the project, together with the Mission Planner button, which greatly simplify the testing workflow.


\subsection{System testing}


\section{Results}


